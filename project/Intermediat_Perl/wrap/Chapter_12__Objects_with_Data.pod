=head2 Chapter 12. 带数据的对象

应用第 I<11> 章介绍的简单的语法, 我们就可以创建类方法, （
多重）继承、重载和扩展。 我们也可以把代码中共同的部份找出来并
用变量代之以重用。 这是面向对象编程的核心概念, 而且对象也提
供实例数据, 这点我们还没有开始了解。

=head2 12. 1. 一匹马属于马类, 各从其类是吗？

让我们看一下我们在第 I<11> 章用于表示动物类和马类的代码：


 { package Animal;
   sub speak {
     my $class = shift;
     print "a $class goes ", $class->sound, "!\n"
   }
 }
 { package Horse;
   @ISA = qw(Animal);
   sub sound { 'neigh' }
 }

这样, 让我们调用 I<Horse->speak> 从而会找到 I<Animal::spe
ak> , 然后会回调 I<Horse::sound> 来取得特定的声音, 其输出是：


 a Horse goes neigh!

但是所有的 I<Horse> 对象都必须完全相同。 如果我们加了一个
方法, 则所有的 I<horses> 对象都自动共享它。 这对于保持对象都
有的共性这点很好, 但是如何捕捉到每个 I<horse> 个体的属性呢？
比如说, 假定我们要给我们的马取个名字。 应该有个方法来区分它
的名字与其它马的名字。

我们可以建立一个实例来实现这个功能。 一个实例一般来说根据
一个类创建, 就是汽车由汽车工厂生产一样。 一个实例有其关联的属
性, 称为实例的变量 (或者叫成员变量, 如果你有C++或 I<Java> 背
景的话). 每个实例有个惟一标识（有些像注册过的赛马的序列号一
样）, 共享属性（赛马的毛色与出色的体力）, 和一般的行为 (e. g
. , pulling the reins back tells the horse to stop).

在 I<Perl> 中, 一个实例必须是一个对内建类的引用.通过最简单
的引用可以保存马的名字, 一个标量引用：[*]

[*] 这是最简单的, 但鲜有在实际的代码中使用, 原因我们后面会
说到。


 my $name = 'Mr. Ed';
 my $tv_horse = \$name;

现在 I<$tv_horse> 是对一个实例数据（马的名字）的引用.最后
一步就是把它变成一个真实的实例, 这要么一个专门的操作符叫 I<b
less:>


 bless $tv_horse, 'Horse';

I<bless> 操作符根据引用找到其指的变量, 在这个例子中, 是标
量 I<$name.> Then it "blesses" that variable, turning $tv_ho
rse into an objecta Horse object, in fact. (想象一个小的标签
说那匹马现在与 I<$name> 关联在一起了。 )

这下, I<$tv_horse> 现在是 I<Horse> 的一个实例 I<.[> +] 那
就是, 它现在是一个不同的马了.而引用并没有改变什么, 它仍然可以
以传统的还原操作符还原 I<.[> +] []

[] 实际上, I<$tv_horse> 指向一个对象, 但是, 在常用的术语来
说, 我们几乎总是用引用与对象打交道来处理对象的.之后, 我们就
可以简单地说 I<$tv_horse> 就是马, 而不是 I<"$tv_horse> 引用的
那个东西"

[] 尽管在一个类之外做这事是个糟糕的想法, 这个我们会在后面
解说。

=head2 12. 2. 调用一个实例方法

方法箭头可以用在实例上, 就像用在包名上（类）一样。 让我们
用 I<$tv_horse> 发声：


 my $noise = $tv_horse->sound;

为了调用 I<sound> 方法, I<Perl> 首先注意到 I<$tvHorse> 是
一个"被祝福"的引用, 所以是一个对象实例。 于是 I<Perl> 创建一
个参数列表, 有些像当我们用类名加方法箭头那种形式。 在这个例子
中, 它就是 I<($tv_horse).> (之后我们会展示参数将跟在实例变量
后面, 就像跟着类一样。 )

现在有趣的地方来了： I<Perl> 被祝福的实例中的类, 在这个例
子中是 I<Horse> , 并用它来定位并调用方法, 就好像我们用的是 I
<Horse->sound> 而不是 I<$tv_horse->sound> 一样。 最初所谓的"
祝福"的目的就是把一个类和它的引用关联起来, 让 I<Perl> 能找到
适当的方法。

在此例中, I<Perl> 直接找到 I<Horse::sound(> 没有用到继承)
, 也就是最终的子程序调用：


 Horse::sound($tv_horse)

注意这里第一个参数仍旧是实例, 不是像以前一样的类名。 I<"n
eigh"> 是输出值, 像以往 I<$noise> 变量一样。

如果 I<Perl> 没有找到 I<Horse::sound> , 那么它会根据 I<@H
orse::ISA> 列表回溯在父类中查找方法, 就象对类方法的操作一样。
类方法和实例方法的区别是第一个参数是否为实例（一个被祝福过
的引用）或一个类名（一个字串）。 [*]

[*] 这同你可能熟悉的其它面向对象语言有所不同。

=head2 12. 3. 访问实例数据

因为我们把实例作为第一个参数, 我们现在可以访问实例自己的数
据.在这个例子中, 让我们添加一个方法来获取一个名字：


 { package Horse;
   @ISA = qw(Animal);
   sub sound { 'neigh' }
   sub name {
     my $self = shift;
     $$self;
   }
 }

现在调用名字：

print $tv_horse->name, " says ", $tv_horse->sound, "\n";

在 I<Horse::name> 中, I<@_> 数组只包含了 I<$tv_horse> , 并
保存到 I<$self> 中。 一般来说它把第一个参数传到实例方法的 I
<$self> 变量中, 所以保持这个风格, 除非你有十足的理由用其它的
风格 (然而, I<Perl> 对 I<$self> 并没有特殊的意义). [] 如果你
把 I<$self> 作为一个标量引用还原, 那么输出 I<Mr.Ed> 是：

[] 如果你有其它面向对象语言的背景, 你可能会用 I<$this> 或
I<$me> 为变量起名, 不过你可能与其它 I<Perl> 面向对象的黑客混
淆。


 Mr. Ed says neigh.

=head2 12. 4. 如何创建 I<Horse>类

如果我们手工创建所有的马, 那我们很可能一次次犯错。 而且暴
露 I<Horse> 内部的信息也违反了面向对象编程的基本原则。 我们不
是兽医, 我们只想拥有一匹马而已。 我们用 I<Horse> 类创建一个
新的马：


 { package Horse;
   @ISA = qw(Animal);
   sub sound { 'neigh' }
   sub name {
     my $self = shift;
     $$self;
   }
   sub named {
     my $class = shift;
     my $name = shift;
     bless \$name, $class;
   }
 }

现在, 用新的 I<named> 方法, 我们来创建一个 I<Horse:>


 my $tv_horse = Horse->named('Mr. Ed');

参考类方法, 所以有两个参数传给 I<Horse::named> , I<"Horse
"> 和 I<"Mr.Ed".> I<Bless> 操作符不仅"祝福"了 I<$name> , 也返
回了 I<$name> 的引用, 所以返回值是对的。 我们就是这样创建一
个 I<horse> 对象。

我们调用构建函数 I<named> 来快速地把参数作为马的名字。 我
们可以用不同名字的构建函数来给对象加上生日（如谱系记录或生日
）。 然而, 大多数人喜欢用 I<new> 来命名构建函数, 并对不同的参
数以不同的解释.只要能太到目的, 两种方法都可以。 I<CPAN> 上大
多数模块用 I<new> , 也有些是例外, 比如 I<DBI> 模块的 I<DBI-
>connect().> 这根据开发者的习俗。

=head2 12. 5. 继承构建函数

对于那个方法中 I<Horse> 类有其它特殊的吗？ 没有。 因此, 它
同样可以继承自 I<Animal> 类, 所以我们可以把它放到这儿：


 { package Animal;
   sub speak {
     my $class = shift;
     print "a $class goes ", $class->sound, "!\n"
   }
   sub name {
     my $self = shift;
     $$self;
   }
   sub named {
     my $class = shift;
     my $name = shift;
     bless \$name, $class;
   }
 }
 { package Horse;
   @ISA = qw(Animal);
   sub sound { 'neigh' }
 }

嗯, 但如果我们在实例上调用 I<speak> 会发生什么呢？


 my $tv_horse = Horse->named('Mr. Ed');
 $tv_horse->speak;

我们会得到一个测试值：


 a Horse=SCALAR(0xaca42ac) goes neigh!

为什么呢?因为 I<Animal::speak> 方法期一个类名作为它的第一
个参数, 而不是一个实例。 当我们传一个实例时, 我们会把"祝福"过
的标量引用当作一个字串, 就像我们直接打印一个引用一样, 不过是
前面有个类名提示。

=head2 12. 6. 让一个方法在类和实例都可以使用

解决这个问题, 我们所要做的就是查这个方法的调用者是个类还是
实例。 最直接的方法是用 I<ref> 操作符。 这个操作符在用在一个
I<blessed> 引用上会返回一个字串（类名）, 而用在一个字串（如
类名）时返回的是空值。 我们改下看看：


 sub name {
   my $either = shift;
   ref $either
     ? $$either                # it's an instance, return name
     : "an unnamed $either";   # it's a class, return generic
 }

这里 I<C<> ? I<:>> 操作符选择是否是还原或是类字串。 现在不
管是实例或者是类我们都可以使用他们。 注意, 我们把第一个参数
位改成 I<$either> 来显示这是有意的：


 print Horse->name, "\n";      # prints "an unnamed Horse\n"


 my $tv_horse = Horse->named('Mr. Ed');
 print $tv_horse->name, "\n";   # prints "Mr. Ed. \n"

我们将使用这个设置叫声：


 sub speak {
   my $either = shift;
   print $either->name, ' goes ', $either->sound, "\n";
 }

因此 I<sound> 方法既可以在类上也可以在实例上运行, 完成了！

=head2 12. 7. 给方法导入参数

现在让我们训练我们的动物会吃：


 { package Animal;
   sub named {
     my $class = shift;
     my $name = shift;
     bless \$name, $class;
   }
   sub name {
     my $either = shift;
     ref $either
       ? $$either # it's an instance, return name
       : "an unnamed $either"; # it's a class, return generic
   }
   sub speak {
     my $either = shift;
     print $either->name, ' goes ', $either->sound, "\n";
   }
   sub eat {
     my $either = shift;
     my $food = shift;
     print $either->name, " eats $food. \n";
   }
 }
 { package Horse;
   @ISA = qw(Animal);
   sub sound { 'neigh' }
 }
 { package Sheep;
   @ISA = qw(Animal);
   sub sound { 'baaaah' }
 }

然后试试：


 my $tv_horse = Horse->named('Mr. Ed');
 $tv_horse->eat('hay');
 Sheep->eat('grass');

输出如下：


 Mr. Ed eats hay.
 an unnamed Sheep eats grass.

一个带实例方法把实际作为参数, 然后是参数列表.调用的样子如
下：


 Animal::eat($tv_horse, 'hay');

一个实际的方法就是一个对象的应用程序接口（ I<API> ）。 一
个好的面向对象的设计很大程度上取决于 I<API> 设计, 因为 I<API
> 决定了对象如何被使用和被维护, 以及其子类应该是什么样子的。
不要在还没有考虑好你（或其他人）如何用这个对象前急急忙忙的确
定 I<API> 设计。

=head2 12. 8. 更有趣的实例

如果一个实例需要更多的数据如何？大多数有用的实例是由许多成
员组成, 而其中每个成员可以是一个引用或另一个对象。 保存这些
成员最简单的办法就是把它们放在一个散列中。 这个散列的键是对象
的名字（也被叫作实例或成员变量）, 而且相应的值就是, 值。

我们把 I<horse> 变成一个散列如何?[*] 回想一下, 所谓对象实
际上是被"祝福"的引用。 我们可以像"祝福"一个标量引用一样容易的
"祝福"一个散列引用, 只要把它们看作引用就可以了。

[*] 就是说不要叫屠夫来就可以了。

让我们做一个有名有色的绵羊：


 my $lost = bless { Name => 'Bo', Color => 'white' }, Sheep;

I<$lost->{Name}> 里存的是 I<"Bo"> , I<$lost->{Color}> 里放
的是 I<white.> 但我们要用 I<$lost->name> 访问 I<name> 变量,
但是因为要用标量引用, 所以会造成混乱.别急, 这很容易解决：


 ## in Animal
 sub name {
   my $either = shift;
   ref $either
     ? $either->{Name}
     : "an unnamed $either";
 }

I<named> 方法创建标量的 I<sheep> 对象, 所以让我们来修改一
下：


 ## in Animal
 sub named {
   my $class = shift;
   my $name = shift;
   my $self = { Name => $name, Color => $class->default_color };
   bless $self, $class;
 }

那么缺省毛色呢？


 ## in Sheep
 sub default_color { 'white' }

然后, 为了不用在每个类都作定义, 我们直接在 I<Animal> 中定
义一个缺省的方法。


 ## in Animal
 sub default_color { 'brown' }

这样, 所有的动物都是棕色（土色, 也许吧）, 除非个别动物特别
指定了毛色, 对这个方法进行了重载。

现在, 因为 I<name> 和 I<named> 是引用这个对象仅有的方法,
所以其它方法可以不变, 这样 I<speak> 仍然可以像以前那样使用。
这就支持了面向对象编程的一条基本法则：如果要访问对象内部数据
, 那修改结构的时候应该用最少的代码修改。

=head2 12. 9. 一匹有不同色彩的马

我们来加一两个方法来设置颜色, 这样让所有出生的马都是棕色。


 ## in Animal
 sub color {
   my $self = shift;
   $self->{Color};
 }
 sub set_color {
   my $self = shift;
   $self->{Color} = shift;
 }

我们可以为 I<Mr.Ed> 修改一下颜色：


 my $tv_horse = Horse->named('Mr. Ed');
 $tv_horse->set_color('black-and-white');
 print $tv_horse->name, ' is colored ', $tv_horse->color, "\n";

其输出是：


 Mr. Ed is colored black-and-white

=head2 12. 10. 取回存储

根据代码的写法, 设置方法也可以返回更新的值.当我们写设值代
码时我们要考虑, 或者要写下来。 设置代码应该返回什么？下面是一
般的答案：

更新过的值 (类似于传入的是什么)

以前的值 (类似于用掩码的方法或选择工作时单值形式的参数)

对象自身

成功／失败码

几种方法各有优缺点.比如, 如果我们返回更新的值, 我们可以将
其用于其它的对象：


 $tv_horse->set_color( $eating->set_color( color_from_user(  ) ));

上面的例子返回新更新的值.一般来说, 这样写代码是容易, 执行
起来也最快。

如果我们返回更改前的值, 我们可以容易地写临时处理程序：


 {
   my $old_color = $tv_horse->set_color('orange'); . . . do things with $tv_horse. . .
   $tv_horse->set_color($old_color);
 }

实现结果是：


 sub set_color {
   my $self = shift;
   my $old = $self->{Color};
   $self->{Color} = shift;
   $old;
 }

为了效率, 我们可以用 I<wantarray> 函数在没有返回值的情况下
不存以前的值：


 sub set_color {
   my $self = shift;
   if (defined wantarray) {
     # this method call is not in void context, so
     # the return value matters
     my $old = $self->{Color};
     $self->{Color} = shift;
     $old;
   } else {
     # this method call is in void context
     $self->{Color} = shift;
   }
 }

如果想返回对象自身, 我们可以链式设置：


 my $tv_horse =
   Horse->named('Mr. Ed')
        ->set_color('grey')
        ->set_age(4)
        ->set_height('17 hands');

这样的代码是可行的, 因为每个设置方法都是原始对象, 成为下个
方法调用对象.还可以这样：


 sub set_color {
   my $self = shift;
   $self->{Color} = shift;
   $self;
 }

避免无返回值的方法这里也可以使用, 尽管我们已经建立了 I<$s
elf> 变量。

最后, 如果程序明显出错, 返回一个返回状态要比一个意外报错要
好.其它的变化会发一个例外并终止程序, 以示程序错误。

总结：经过考虑后, 按需要应用, 但无论如何要写下来（而且在发
布后不要再改）

=head2 12. 11. 不要往盒子里看

我们可以通过下面的散列引用 I<$tv_horse->{Color}> 通过类的
外部来获取或设置颜色。 然而, 这样就因为暴露了内部结构而违反了
对象的封装性。 对象应该是一个黑盒, 而我们已经撬开了绞链, 看
到了里边。

面向对象设计的目标之一就是要让 I<Animal> 或 I<Horse> 的代
码维护者在进行合理独立的改动方法的实现的时候, 使接口仍然可以
工作。 要看为什么直接访问散列就破坏了封装, 让我们打个比方, 如
果我们不用简单的颜色名字来代表颜色, 而是用 I<RGB> 三色数字来
代表颜色（用一个数组引用来代表）。 在这个例子中, 我们用一个
假想的（写这本书的时候） I<Color::Conversions> 模块来改幕后的
色彩格式：


 use Color::Conversions qw(color_name_to_rgb rgb_to_color_name); . . .
 sub set_color {
   my $self = shift;
   my $new_color = shift;
   $self->{Color} = color_name_to_rgb($new_color);  # arrayref
 }
 sub color {
   my $self = shift;
   rgb_to_color_name($self->{Color});               # takes arrayref
 }

我们可以在维护旧的接口时一样可以用设置和取值程序, 因为在用
户不知道具体细节的情况下他们可以自动转换.我们也可以添加新的
方法来直接改 I<RGB> 三色数字：


 sub set_color_rgb {
   my $self = shift;
   $self->{Color} = [@_];                # set colors to remaining parameters
 }
 sub get_color_rgb {
   my $self = shift;
   @{ $self->{Color} };                  # return RGB list
 }

如果我们在类的外面直接看 I<$tv_horse->{Color}> , 这样的改
变是不可能的。 它不能在存数组引用（ I<[0> , 0, I<255]> ）的地
方存字串（ I<'blue'> ）或把数组引用当作字串。 这就是为什么面
向对象的编程鼓励你用设置器或取值器, 尽管他们可能费些写代码的
时间。

=head2 12. 12. 更快的取值器和设置器

因为我们打算总以比较良好的方式调用取值器和设置器, 而不直接
改变数据结构, 设置器和取值器会被调用得很频繁。 为了节约调用
时间, 我们可以看到他们被写成这样：


 ## in Animal
 sub color     { $_[0]->{Color} }
 sub set_color { $_[0]->{Color} = $_[1] }

写这些代码的时候我们省了点儿时间, 代码执行也快了点儿, 尽管
对于这些代码在我们的程序里具体发挥什么作用可能也不太了解。
变量 I<$_[0]> 是访问 I<@_> 数组的第一个元素。 相比于把数组的
变量放到另一个变量中的作法, 我们简单的直接引用它。

=head2 12. 13. 既是设置器也是取值器

另一种建立设置器和取值器替代方案是用一个方法, 以参数作区分
是取值还是设置值。 如果参数缺失, 那么就作取值操作; 如果有值
, 那就设置值。 简例如下：


 sub color {
   my $self = shift;
   if (@_) {              # are there any more parameters?
     # yes, it's a setter:
     $self->{Color} = shift;
   } else {
     # no, it's a getter:
     $self->{Color};
   }
 }

这样我们就可以这样写：


 my $tv_horse = Horse->named('Mr. Ed');
 $tv_horse->color('black-and-white');
 print $tv_horse->name, ' is colored ', $tv_horse->color, "\n";

第二行出现的参数表明我们正设置颜色, 如果它缺失, 表示我们调
用取值器。

这种方案具有吸引力是因为其简洁, 但这也有其缺点.它混淆了频
繁的取值的动作.它也使通过我们的代码来找用特殊参数的设置器变得
困难, 而这往往比取值重要.在以往, 因为一个设置器因为在升级后
另一个函数返回多个值而变成了取值器的情况造成的麻烦就很多 I<.
<> 似乎应该反过来－－译者>

=head2 12. 14. 将方法限制成类的或对象实例的

给一个无法命名的抽象的"马"起名字多半不是个好主意; 对实例也
是一样。 在 I<Perl> 语言中没有一种方法定义"这是一个类的方法
" 或"这是一个对象实例的方法 I<".> 好在 I<ref> 操作符让我们可
以在调用出错的时候抛出一个异常。 考虑下面一个仅仅是"实例"或"
类"方法的例子, 我们用参数来决定下面一步是什么：


 use Carp qw(croak);


 sub instance_only {
   ref(my $self = shift) or croak "instance variable needed"; . . . use $self as the instance. . .
 }


 sub class_only {
   ref(my $class = shift) and croak "class name needed"; . . . use $class as the class. . .
 }

I<ref> 函数对于实例会返回 I<true> , 对于被"祝福"的引用也是
一样, 如果是类就返回 I<false> , 就是个字串。 如果它返回一个
我们不要的值, 我们可以用 I<Carp> 模块（在标准发行版）中的 I<
croak> 函数。 I<croak> 函数把出错信息看上去好像是调用者发出的
一样, 而不是被调用的函数发出。 这样调用者会得到如下的出错信
息, 并显示调用者的行号：


 instance variable needed at their_code line 1234

I<croak> 提供了 I<die> 函数的替代方案, I<Carp> 模块同样提
供 I<carp> 来替代 I<warn> 的方案。 它们都指出出问题的调用函数
所在的行号。 我们可以在代码中用 I<die> 和 I<warn> 一样用 I<
Carp> 模块中的函数。 你的用户会因此感谢你的。

=head2 12. 15. 练习

答案索引找

=head2 12. 15. 1. 练习 ［ I<45> 分钟］

给 I<Animal> 类添加设置和取得名字和颜色的能力。 要保证在
I<use> I<strict> 下能运行.而且要保证 I<get> 方法在类和实例情
况下都能工作.并以以下代码测试：


 my $tv_horse = Horse->named('Mr. Ed');
 $tv_horse->set_name('Mister Ed');
 $tv_horse->set_color('grey');
 print $tv_horse->name, ' is ', $tv_horse->color, "\n";
 print Sheep->name, ' colored ', Sheep->color, ' goes ', Sheep->sound, "\n";

要在类层面设置名字或颜色, 你该如何做？

