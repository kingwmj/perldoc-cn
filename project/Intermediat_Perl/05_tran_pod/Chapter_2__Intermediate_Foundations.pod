=head2 Chapter 2. 进阶基础

在开始深入学习这本书之前, 我们要介绍一些中阶 I<Perl> 语言的 I<B<"> 习惯用语 I<">> ，我们会在整本书里都用到这些 I<B<"> 习语 I<">>. 对这些 I<B<"> 习语 I<">> 的掌握程度区分了一个程序员对 I<Perl> 的运用等级是中阶还是初阶. 我们将会在贯穿整本书的例子里向您介绍这些 I<B<"> 演员 I<">>.

=head2 2. 1. 列表操作符

你可能已经知道 I<Perl> 的一些列表操作符, 但并没有想过他们是怎么同列表一起工作的.最常用的列表操作符应该是 I<print> 了。 我们给它一些参数, 然后它把他们合在一起显示出来。

  print 'Two castaways are ', 'Gilligan', ' and ', 'Skipper', "\n";

在 I<B<Learning> I<Perl>> 这本书里, 你可能知道了另外一些列表操作符。 如 I<sort> 操作符将输入的列表按顺序列出。 在 I<Gilligan's> I<Island> 的主题歌中的那些求生者没有按字母次序出场, I<sort> 可以为我们修正这一点。

  my @castaways = sort qw(Gilligan Skipper Ginger Professor Mary-Ann);

I<C<reverse>> 操作符返回反向排序的列表。

  my @castaways = reverse qw(Gilligan Skipper Ginger Professor Mary-Ann);

I<Perl> 还有其它与列表打交道的操作符.而且一旦你使用他们, 你会发现这些语句会使你表达得更清楚, 写更少的代码。

=head2 2. 1. 1. 用 I<grep> 操作符来过滤列表

I<grep> 操作符取一个列表和一个"测试表达式 I<".> 它一个一个地从列表中把元素取出来放到 I<$_> 变量中, 并在标量环境中, 用"测试表达式"来检验这个值.如果检验出来是个"真"值, I<grep> 会把 I<$_> 变量送到输出列表中。

  my @lunch_choices = grep &is_edible($_), @gilligans_posessions.

在一个列表上下文中, I<grep> 操作符会返回所有被选出元素的列表.而在一个标量上下文中, I<grep> 返回被选出元素的个数。

  my @results = grep EXPR, @input_list;
  my $count   = grep EXPR, @input_list;

在下面的例子中, I<EXPR> 代表一个返回标量的表达式, 它引用 I<$_> 变量（显式或隐式的）.比如找出大于 I<10> 的数, I<EXPR> 表达式来处理 I<$_> 是否大于 I<10.>

  my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
  my @bigger_than_10 = grep $_ > 10, @input_numbers;

输出结果当然是： I<16> , I<32> 和 I<64.> 上例中显式地引用了变量 I<$_.> 下面有个隐式引用变量 I<$_> 的例子, 在正则表达式中隐式引用了变量 I<$_:>

  my @end_in_4 = grep /4$/, @input_numbers;

现在我们得到的输出是4和 I<64.>

当 I<grep> 工作的时候, 它是从 I<$_> 变量中把值"借"出来用.就是说 I<grep> 把 I<$_> 的值"借"过来用一下, 用完后再把原值放回 I<$_> 变量中.所以 I<$_> 变量仅仅是拷贝一下值而己.是实际数据元素的一个别名.就像 I<foreach> I<loop> 中的控制变量。

如果检验表达式太复杂, 我们可以把检验代码隐藏到一个子例程里去：

 my @odd_digit_sum = grep digit_sum_is_odd($_), @input_numbers;

 sub digit_sum_is_odd {
     my $input = shift;
     my @digits = split //, $input;  # Assume no nondigit characters
         my $sum;
     $sum += $_ for @digits;
     return $sum % 2;
 }

对于这个例子, 我们得到的输出是1, I<16> 和 I<32.> 程序把这些数据的数位加起来后, 因为最后一行返回的余数都是 I<"1"> , 所以返回值为"真 I<".>

所以, I<grep> 语法有两种形式：前面秀给你们看的表达式形式和下面要展示给你们看的代码块形式.因为代码只用一次, 我们现在不把代码放到子例程中, 而是以代码块的形式直接放在 I<grep> 语法里, 所谓的块形式：[*][*]

[*] 在 I<grep> 的块形式中, 代码块和输入数组中间是没有逗号的.而在 I<grep> 的表达式形式中, 表达式和输入数组中间必须要有一个逗号.区别如下：

 my @results = grep {
     block;
     of;
     code;
 } @input_list;

 my $count = grep {
     block;
     of;
     code;
 } @input_list;

同 I<grep> 的表达式形式一样, I<grep> 临时把输入数组中每个元素放到 I<$_> 中去, 然后, 它用代码块来处理这个值.代码块里最后一个表达式来检验值.就像所有的测试表达式一样, 在标量上下文来检验值.因为是完整的块, 所以我们可以在其中用以块为范围的变量.我们来用块形式重写上面的例子：:

 my @odd_digit_sum = grep {
     my $input = $_;
     my @digits = split //, $input;   # Assume no nondigit characters
         my $sum;
     $sum += $_ for @digits;
     $sum % 2;
 } @input_numbers;

注意与用子例程的方法有两个地方的变化：输入值是通过变量 I<$_> , 而不是输入参数列表, 而且在代码块形式中我们去掉了 I<return> 关键字.实际上如果我们保留 I<return> 的话是会出错的, 因为我们不是在用一个子例程, 仅仅是一个代码块 I<.[> *]当然, 这个例子我们还可以优化一下, 去掉中间变量：

[*] 保留 I<return> 的结果会导致 I<Perl> 从包含这个代码块的子例程中退出.当然, 我们中有些人在最初编程的时候就深受其苦。

 my @odd_digit_sum = grep {
     my $sum;
     $sum += $_ for split //;
         $sum % 2;
 } @input_numbers;

如果显式使用中间变量能使代码让你和你的同事更易理解和维护代码的话, 尽管用它.好代码才是主要的。

=head2 2. 1. 2. 用 I<map> 作列表的转换

I<map> 操作符的语法同 I<grep> 操作符非常相像, 他们有相同的操作步骤.例如它们都是把输入列表中的元素临时地放到 I<$_> 变量中去, 而且他们的语法中都有表达式形式和代码块形式。

然而, I<grep> 中的测试表达式在 I<map> 中变成了映射表达式 I<.map> 操作符在列表环境中为表达式求值（而不是像 I<grep> 那样在标量环境下求值）.每次表达式求值都成为整个输出结果的一部分.为各个元素求值结果连在一起成为完整全部的输出.在标量环境下, I<map> 返回在输入列表里多少个元素被处理.但是 I<map> 应该总是用在列表环境下, 很少用在标量环境下。

让我们开始一个简单的实例：:

  my @input_numbers = (1, 2, 4, 8, 16, 32, 64);
  my @result = map $_ + 100, @input_numbers;

七个项目依次映射为 I<$_> , 我们得到了一个结果：比 I<100> 这个输入大的数字。所以 I<@result> 的结果是： I<101> , I<102> , I<104> , I<108> , I<116> , I<132> 和 I<164>

但是我们没有限定每个输入对应一个输出，让我们看看当一个输入对应两个输出的时候发生了什么。

  my @result = map { $_, 3 * $_ } @input_numbers;

现在对应每个输入有两个输出了：1, 3, 2, 6, 4, I<12> , 8, I<24> , I<16> , I<48> , I<32> , I<96> , I<64> 和 I<192.> 我们可以这些对数字保存为散列来保存一个数字对应三倍与它的数值对。

  my %hash = @result;

或者，不使用中间数组直接使用 I<map> 生成结果。

  my %hash = map { $_, 3 * $_ } @input_numbers;

你可以看到 I<map> 功能强大，我们可以将一个列表的每个元素映射为多个元素。事实上我们很少一对一的生成列表的输出。让我们看看拆分一个数字后发生了什么。

  my @result = map { split //, $_ } @input_numbers;

大括号内的代码将数字拆分成单个的数字。对于 1, 2, 4 和 8，我们得到了一对一的结果。对于 I<16> , I<32> 和 I<64> , 我们得到了一对二的结果。当我们使用 I<map> 连接这些结果，我们最后得到 1, 2, 4, 8, 1, 6, 3, 2, 6, 和 I<4.>

如果我们特别用一个空列表传入， I<map> 将空列表变成更大的列表，列表依然是空的。我们利用这个特性选择并且剔除一些项目。例如，我们只想拆分后以 4 结尾的结果：

 my @result = map {
     my @digits = split //, $_;
     if ($digits[-1] == 4) {
         @digits;
     } else {
         ();
     }
 } @input_numbers;

如果最后的数字是 4，我们原样返回 I<@digits> (列表环境 I<).> 如果最后的数字不是 4，我们返回一个空列表，这样就剔除了指定的数值。这样，我们使用 I<map> 达到了 I<grep> 的效果。但反过来就不行了。

当然，所有我们能用 I<map> 和 I<grep> 做的事情，都可以用 I<foreach> 循环来做。但是话又说回来，我们也可以用汇编或者 I<toggling> I<bits> 来写代码。 [*] 重点是正确的应用 I<grep> 和 I<map> 能降低程序的复杂程度。让我们可以更关注更高级的问题而不是拘泥于细节。

=head2 2. 2. 用 I<eval> 捕捉错误

有一些代码看上去很平常, 但是却含有潜在的危险, 一旦某种条件不对就会使程序中断, 过早地结束程序。

  my $average = $total / $count;                # divide by zero?
  print "okay\n" unless /$match/;                # illegal pattern?

  open MINNOW, '>ship. txt'
  or die "Can't create 'ship. txt': $!";        # user-defined die?

  &implement($_) foreach @rescue_scheme;        # die inside sub?

可是, 不能因为代码的某一片断出错而使我们的整个程序崩溃。 I<Perl> 用 I<eval> 操作符来实现捕捉错误的机制。.

  eval { $average = $total / $count } ;

如果在 I<eval> 块里代码发生错误, 系统会退出这个块。 但是, 尽管退出块, I<Perl> 会继续执行 I<eval> 块之外的代码。 我们在 I<eval> 块的后面一般做法是检查一下 I<$@> 变量, 这个变量要么是空（表示没有出错）或者代码出错时系统返回的"遗言", 多半是"除零错误"之类云云。.

  eval { $average = $total / $count } ;
  print "Continuing after error: $@" if $@;

  eval { &rescue_scheme_42 } ;
  print "Continuing after error: $@" if $@;

I<eval> 块的结束时的分号是必须的, 因为不像 I<if> 或者 I<while> 那样的控制结构, I<eval> 实际上是个函数。 但是代码块是真的块, 所以可以包括词法变量（ I<my> 修饰的变量）和另外其它的断言语句。 因为是个函数, I<eval> 有像子例程那样的返回值（最后一个表达式的求值结果, 或者由 I<return> 语句返回的结果）。 当然, 如果代码块失败则没有值返回;如果在标量环境将返回未定义值, 在列表环境将返回一个空的列表。 因此, 比较安全的求平均值的代码的写法如下：

  my $average = eval { $total / $count } ;

现在, 根据这个操作执行的成败, 变量 I<$average> 要么是两数之商要么是个未定义值。

I<Perl> 也支持 I<eval> 代码块的嵌套.只要代码执行, I<eval> 块总能捕捉错误, 所以它能捕捉嵌套子例程里发生的错误.尽管如此, I<eval> 不能捕捉到非常严重的错误, 这些错误发生时 I<Perl> 自己会中断执行.这些错误包括无法捕捉的信号, 内存溢出或其它的灾难 I<.eval> 同样不能捕捉到语法错误;因为 I<Perl> 在编译 I<eval> 及其它代码的时候检查语法错误, 而不是在运行时.还有, I<eval> 也不能捕捉警告.（但是 I<Perl> 的确提供一个方法来捕捉警告信息;可以查阅一下变量 I<$SIG{__WARN__}>）.

=head2 2. 3. 用 I<eval> 动态编译代码

I<eval> 有另外一种用法, 其参数是作为一个字串表达式, 而不是代码块。 在运行时, 它将字串临时编译成代码并且执行.这很易用, 但也很危险, 因为有可能会把具有危害性的代码放到字串里。 除了极少数值得一提的例外情况, 我们建议你尽量避免这种用法。 稍后我们会用这种用法, 然后我们就不用这种用法了, 我们只是展示它是怎么工作的。

  eval '$sum = 2 + 2';
  print "The sum is $sum\n";

I<Perl> 在词法环境中执行那段代码, 这意味着我们好像在执行的时候输入这些代码的一样。 I<eval> 的结果就是最后一个表达式求值的值, 所以我们不必在 I<eval> 中输入整个语句。

 #!/usr/bin/perl

 foreach my $operator ( qw(+ - * /) ) {
     my $result = eval "2 $operator 2";
     print "2 $operator 2 is $result\n";
 }

上例中, 我们依次把 + - * / 四个操作符用到我们的 I<eval> 代码块中。 在给 I<eval> 的字串中, 我们内插了变量 I<$operator> 的值。 I<eval> 执行并返回了我们给出字串的值, 并且放到变量 I<$result> 中。

如果 I<eval> 不能正确编译和执行我们传给它的 I<Perl> 代码, 它就会像代码块形式的结果一样设置变量 I<$@> 一个值。 在下例中, 我们想要捕捉任何除零错误, 但我们遇到了另外一种错误 I<--> 分母缺失。

  print 'The quotient is ', eval '5 /', "\n";
  warn $@ if $@;

I<eval> 捕捉语法错误, 然后在我们调用 I<eval> 后, 在检查 I<$@> 值时, 把出错信息放到变量 I<$@> 中。

The quotient is

  syntax error at (eval 1) line 2, at EOF

在稍后的第 I<10> 、 I<17> 和 I<18> 章中, 我们会用这种办法来调用可选模块。 如果我们调用模块失败, I<Perl> 会中止程序。 而我们会捕捉到这种错误, 并由我们自己以我们的办法恢复程序的运行。

万一你还没有注意我们的警告, 我们在这里重申：要非常小心这种形式的 I<eval> 用法。 如果你有其它的方法来替代 I<eval> 用法, 那就试试其它方法。 我们在后来第 I<10> 章会用到这种办法从外部文件中载入代码, 但我们同样会向你展示出更好的替代方案。

=head2 2. 4. 习题

答案在附录中的"第二章的答案"中;

=head2 2. 4. 1. 习题 1 I<[15> 分钟]

写一个程序从命令行取一个文件清单, 然后用 I<grep> 把那些文件大小在 I<1000> 字节以内的文件找出来。 用 I<map> 把这个清单里的每个字串前加四个空格并在字串后面加上换行符。 然后输出列表结果。

=head2 2. 4. 2. 练习 2 I<[25> 分钟]

写一个程序要求用户输入一个正则表达式的模板。 不要以命令行参数形式输入, 要从键盘读取。 然后从一些目录中（可以是硬编码的, 如： I<"/etc"> 或 I<'C:\\Windows'> ）中读取符合模板的文件名。 重复这个操作直到用户输入空串。 要屏蔽用户输入的正斜杠 I<("/")> , 因为那是 I<Perl> 里正则表达式的分隔符;输入的模板用换行符为分隔。 要保证不会因为用户输入了一个错误的正则表达式, 如括号不匹配之类的, 而导致程序崩溃。


